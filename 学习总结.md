# java学习的大体路线

![学习路线](D:\git\picture\微信图片_20200630213416.jpg)

计划

> 自己关于如何学好的初步尝试：
>
> ​	1.在项目中学习相关技术，因为自己学的话根本不知道从何学起，只有通过**项目视频**来总结相关技术。
>
> ​    2.利用好平时的时间，*明确自己要学习什么*？
>
> ​    3.**一定要提高效率！！！**
>
> ​    4.**定好目标**，明确自己在一段时间内的的目标，**以一段时间为单位制定计划**。包括制定好每天要学习什么，每天要完成什么。
>
> |    Monday    | Tuesday | Wednesday |       Thursday       | Friday | Saturday |
> | :----------: | :-----: | :-------: | :------------------: | :----: | :------: |
> |              |         |           |                      |        |          |
> |   学习算法   |         |           |      看JVM视频       |        |          |
> |              |         |           |                      |        |          |
> | 看spring相关 |         |           | 看并发编程相关的视频 |        |          |
> |              |         |           |                      |        |          |
> |              |         |           |                      |        |          |
> |              |         |           |                      |        |          |
> |              |         |           |                      |        |          |
>
> 

## 第一章 java基础

## 第二章 spring相关

### 一、Spring注解驱动开发

#### 1. 组件注册

##### 1.1 常用注解

1.1.1 **@Configuration**和**@Bean**

1.1.2 **@ComponentScan**

1.1.3 **@Scope**

1.1.4 **@Lazy**

1.1.5 **@Conditional**

1.1.6 **@Import**



### 二、SpringBoot

## 第三章 mybatis和mysql相关

## 第四章 JVM相关

#### 

## 第五章 消息中间件

## 第六章 分布式缓存

### 一、NoSQL

#### 1. NoSQL数据库的概述

* NoSQL(not only sql)泛指非关系型数据库。

* NoSQL不依赖业务逻辑方式存储，而是以简单的key-value方式存储。

* 它不遵循SQL标准

* 不支持ACID（事务）

* 远超SQL性能

* 适用场景：高并发的读写，海量数据的读写，对数据高可扩展性。

* 不适用场景：需要事务支持，基于sql的结构化存储，处理复杂的关系。

* 非关系型数据库

  Memcached、Redis、mongoDB是最接近关系型数据库的非关系型数据库。

### 二、Redis

#### 1. Redis简介

#### 2. Redis安装和启动

##### 2.1 启动

+ 备份redis.conf：拷贝一份redis.conf到其他目录

  ```
  mkdir /opt/myRedis
  cp redis.conf /opt/myRedis/redis.conf
  
  ```

* 将Redis.conf文件中的deamonize no改成deamonize yes

* 启动命令：执行`redis-server 所在路径/redis.conf`

* 客户端访问`redis-cli`

* 测试验证:`ping`

  ```
  127.0.0.1:6379> ping
  PONG
  ```

* 关闭`redis-cli shotdown`,或者进入终端`shutdown`

* 默认**16**个数据库，类似于数组下标从0开始，统一密码管理，**所有库都是同样的密码**。使用命令 `select `库的下标  来切换数据库，例如  select 8

* Redis是单线程+多路IO复用技术

  

#### 3. Redis的五大基本类型

##### 3.1 Redis的数据类型

* key       +              string

  ​                               set

  ​                              list

  ​                              hash

  ​                             zset

  

##### 3.2 key

* `keys *`查看当前库的所有键。
* `exists <key>`判断某个键是否存在
* `type <key>`查看键的类型
* `del <key>`删除某个键
* `expire <key> <seconds>`为键值设置过期时间，单位秒
* `ttl <key>`查看还有多久过期，**-1**表示永不过期，**-2**表示已过期
* `dbsize`查看当前数据库中key的数量
* `flushdb`清空当前库
* `Flushall`通杀全部库



##### 3.3 String

* String是Redis最基本的类型，一个key对应着一个value。

* String是**二进制**安全的，这意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

* String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。

* 常规操作

  |                                        |                                                              |
  | :------------------------------------: | :----------------------------------------------------------: |
  |               get <key>                |                         查询对应键值                         |
  |           set <key> <value>            |                          添加键值对                          |
  |          append <key> <value>          |               将给定的<value>追加到原值的末尾                |
  |              strlen <key>              |                         获取值的长度                         |
  |           senx <key> <value>           |                只有在key 不存在时设置key的值                 |
  |               incr <key>               | 将key中存储的数字值增1<br/>只能对数字值操作，如果为空，新增值为1 |
  |               decr <key>               | 将key中存储的数字值减1<br/>只能对数字之操作，如果为空,新增值为-1 |
  |       incrby /decrby <key> 步长        |             将key中存储的数字值增减，自定义步长              |
  |  mset <key1> <value1> <key2> <value2>  |                同时设置一个或多个key-value对                 |
  |       mget <key1> <key2> <key3>        |                   同时获取一个或多个value                    |
  | msetnx <key1> <value1> <key2> <value2> | 同时设置一个或多个key-value对<br/>，当且仅当所有给定的key都不存在 |
  |  getrange <key> <起始位置> <结束位置>  |              获得值的范围,类似java中的substring              |
  |   setrange <key> <起始位置> <value>    |  用<value>覆盖<key>所存储的字符串值<br/>，从<起始位置>开始   |
  |     setex <key> <过期时间> <value>     |             设置键值的同时，设置过去时间，单位秒             |
  |          getset <key> <value>          |              以新换旧,设置了新值的同时获取旧值               |

* **incr key 操作的原子性**

  a. 所谓的原子性操作就是不会被线程调度机制所打断，这种操作一旦开始就一直运行到结束。

  b. 在单线程中，能够在单条指令内完成的操作，都可以看为“原子操作”，因为中断只能发生于指令之间。

  c. **Redis**单命令的原子性主要得益于**Redis的单线程**。



##### 3.4 List

* 单键多值

* Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的**头部（左边）**或者**尾部（右边）**

* ![image-20200809225205763](D:\git\picture\image-20200809225205763.png)

* 常用操作

  |                                        |                                                     |
  | :------------------------------------: | :-------------------------------------------------: |
  | lpush/rpush   <key> <value1> <value2>  |            从左边/右边插入一个或多个值。            |
  |        rpoplpush <key1> <key2>         | 从<key1>列表右边吐出一个值，<br/>插到<key2>列表左边 |
  |      lrange <key> <start> <stop>       |           按照索引下标获得元素(从左到右)            |
  |          lindex <key> <index>          |           按照索引下标获得元素(从左到右)            |
  |               llen <key>               |                    获得列表长度                     |
  | insert <key> before <value> <newvalue> |        在<value>的后面插入<newvalue> 插入值         |
  |         lrem <key> <n> <value>         |            从左边删除n个value(从左到右)             |



##### 3.5 Set

* Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以**自动排重**的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且**set提供了判断某个成员是否在一个set集合内**的重要接口，这个也是list所不能提供的。

* Set是string类型的无序集合，它的底层是value为null的hash表。

* 常用操作

  |                                   |                                                              |
  | :-------------------------------: | :----------------------------------------------------------: |
  | sadd <key> <value1> <value2> .... | 将一个或多个 member 元素加入到集合 key 当中，<br/>已经存在于集合的 member 元素将被忽略。 |
  |          smembers <key>           |                     取出该集合的所有值。                     |
  |           scard  <key>            |                    返回该集合的元素个数。                    |
  | srem <key> <value1> <value2> .... |                    删除集合中的某个元素。                    |
  |            spop <key>             |                  随机从该集合中吐出一个值。                  |
  |       srandmember <key> <n>       |        随机从该集合中取出n个值。<br/>不会从集合中删除        |
  |       sinter <key1> <key2>        |                   返回两个集合的交集元素。                   |
  |       sunion <key1> <key2>        |                   返回两个集合的并集元素。                   |
  |        sdiff <key1> <key2>        |                   返回两个集合的差集元素。                   |

  

##### 3.6 Hash

* hash 是一个键值对集合

* hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

* 类似Java里面的Map<String,Object>

* 常用操作

  |                                                     |                                                              |
  | :-------------------------------------------------: | :----------------------------------------------------------: |
  |            hset <key>  <field>  <value>             |             给<key>集合中的 <field>键赋值<value>             |
  |                 hget <key1> <field>                 |                从<key1>集合<field> 取出 value                |
  | hmset <key1> <field1> <value1> <field2> <value2>... |                       批量设置hash的值                       |
  |                 hexists key <field>                 |          查看哈希表 key 中，给定域 field 是否存在。          |
  |                     hkeys <key>                     |                  列出该hash集合的所有field                   |
  |                     hvals <key>                     |                  列出该hash集合的所有value                   |
  |          hincrby <key> <field> <increment>          |       为哈希表 key 中的域 field 的值加上增量 increment       |
  |            hsetnx <key> <field> <value>             | 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 |

  

##### 3.7 zset

* Redis有序集合zset与普通集合set非常相似，是一个**没有重复元素的字符串集合**。不同之处是**有序集合的每个成员都关联了一个评分（score）** ，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。**集合的成员是唯一的，但是评分可以是重复了** 。

* 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。

* 常用操作

  |                                                              |                                                              |
  | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |      zadd <key> <score1> <value1> <score2> <value2>...       |  将一个或多个 member 元素及其 score 值加入到有序集 key 当中  |
  |           zrange <key> <start> <stop> [WITHSCORES]           | 返回有序集 key 中，下标在<start> <stop>之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。 |
  | zrangebyscore key min max [withscores] [limit offset count]  | 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 |
  | zrevrangebyscore key max min [withscores] [limit offset count] |                   同上，改为从大到小排列。                   |
  |              zincrby <key> <increment> <value>               |                    为元素的score加上增量                     |
  |                      zrem <key> <value>                      |                  删除该集合下，指定值的元素                  |
  |                   zcount <key> <min> <max>                   |               统计该集合，分数区间内的元素个数               |
  |                     zrank <key> <value>                      |              返回该值在集合中的排名，从0开始。               |

  



#### 4. Redis事务

##### 4.1 Redis中事务的定义

Redis的实务是一个单独隔离的操作：事务中所有的命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他的客户端发过来的请求所打断。**Redis事务的主要作用就是串联多个命令防止别的命令插队。**

##### 4.2 multi 、exec、discard

从输入multi命令开始，输入的命令都会进入到命令队列中，等待执行，当输入exec之后，Redis会将命令队列里的命令依次执行。

```
127.0.0.1:6379> set a1 100
OK
127.0.0.1:6379> set a2 200
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> incr a1
QUEUED
127.0.0.1:6379> decr a2
QUEUED
127.0.0.1:6379> exec
1) (integer) 102
2) (integer) 199
```

在组队的过程中可以通过discard来放弃组队。

```
127.0.0.1:6379> multi
OK
127.0.0.1:6379> incr a1
QUEUED
127.0.0.1:6379> discard
OK
127.0.0.1:6379> exec
(error) ERR EXEC without MULTI
127.0.0.1:6379>
```

![image-20200901003209950](D:\git\picture\image-20200901003209950.png)



##### 4.3 事务中的错误处理

1. 组队中某个命令出现了报告错误，执行时整个的所有队列会都会被取消。

   ![image-20200901003809370](D:\git\picture\image-20200901003809370.png)

   ```
   127.0.0.1:6379> multi
   OK
   127.0.0.1:6379> incr a1
   QUEUED
   127.0.0.1:6379> decrs a2
   (error) ERR unknown command `decrs`, with args beginning with: `a2`, 
   127.0.0.1:6379> exec
   (error) EXECABORT Transaction discarded because of previous errors.
   127.0.0.1:6379> 
   ```

2. 如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，**而其他的命令都会执行，不会回滚**。

   ![image-20200901004034030](D:\git\picture\image-20200901004034030.png)

   ```
   127.0.0.1:6379> multi
   OK
   127.0.0.1:6379> get a1
   QUEUED
   127.0.0.1:6379> get a2
   QUEUED
   127.0.0.1:6379> set a3 a
   QUEUED
   127.0.0.1:6379> incr a3
   QUEUED
   127.0.0.1:6379> exec
   1) "102"
   2) "199"
   3) OK
   4) (error) ERR value is not an integer or out of range
   127.0.0.1:6379> 
   ```

    

##### 4.4 Redis事务的使用

1. **WATCH key[key….]**在multi执行之前在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。
2. **unwatch**取消 WATCH 命令对所有 key 的监视。

3. 事务的三个特性

   * 单独的隔离操作

     ​    事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

   * 没有隔离级别的概念

     ​    队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 

   * 不能保证原子性

     Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚



#### 5. Redis 持久化

Redis提供了2个不同形式的持久化方式 RDB 和 AOF。

##### 5.1 RDB

1. 在指定时间间隔内**将数据集快照写入磁盘**，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。

2. 备份是如何执行的：

   > ​     Redis会**单独**创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

3. RDB保存的文件

   在redis.conf中配置文件名称，默认为dump.rdb.

   ```
   # The filename where to dump the DB
   dbfilename dump.rdb
   ```

4. RDB文件的保存路径

   默认为Redis启动时命令行所在的目录下,也可以修改

   ```
   # Note that you must specify a directory here, not a file name.
   dir /usr/local/redis_dbfile/
   ```

5. RDB的保存策略

   ```
   #   In the example below the behaviour will be to save:
   #   after 900 sec (15 min) if at least 1 key changed
   #   after 300 sec (5 min) if at least 10 keys changed
   #   after 60 sec if at least 10000 keys changed
   save 900 1
   save 300 10
   save 60 10000
   ```

6. 手动保存快照

​        bgsave:按照保存策略自动保存

7. RDB的相关配置

* stop-writes-on-bgsave-error yes :Redis无法写入磁盘的话，直接关掉Redis的写操作
* rdbcompression yes  :进行rdb保存时，将文件压缩
* rdbchecksum yes   :在存储快照后，还可以让Redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。

8. RDB的备份与恢复

   恢复: 关闭Redis，把备份的文件拷贝到工作目录下,启动redis,备份数据会直接加载。

9. RDB的优缺点

* 优点: 节省磁盘空间,恢复速度快
* 缺点: 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。

##### 5.2 AOF

1. ​    以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
2. AOF默认不开启，需要手动在配置文件中配置

    ```
    # AOF and RDB persistence can be enabled at the same time without problems.
    # If the AOF is enabled on startup Redis will load the AOF, that is the file
    # with the better durability guarantees.
    #
    # Please check http://redis.io/topics/persistence for more information.
    
    appendonly no
    ```
3. 可以在redis.conf中配置文件名称，默认为 appendonly.aof

   ```
   # The name of the append only file (default: "appendonly.aof")
   
   appendfilename "appendonly.aof"
   ```

**AOF文件的保存路径，同RDB的路径一致。**

4. **AOF和RDB同时开启，AOF起主要作用。**

5. AOF文件故障备份

   ​    AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。

6. AOF同步频率设置

   ```
   # If unsure, use "everysec".
   # appendfsync always
   appendfsync everysec
   # appendfsync no
   ```

   * 始终同步，每次Redis的写入都会立刻记入日志
   * l 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。
   * 把不主动进行同步，把同步时机交给操作系统。

7. Rewrite

      AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

   何时重写？

   ```
   # Specify a percentage of zero in order to disable the automatic AOF
   # rewrite feature.
   
   auto-aof-rewrite-percentage 100
   auto-aof-rewrite-min-size 64mb
   ```

      系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,如果Redis的AOF当前大小>= base_size +base_size*100% (默认)且当前大小>=64mb(默认)的情况下，Redis会对AOF进行重写。

8. AOF的优缺点
   * 优点 : 备份机制更稳健，丢失数据概率更低。可读的日志文本，通过操作AOF稳健，可以处理误操作。
   * 缺点 : 比起RDB占用更多的磁盘空间, 恢复备份速度要慢, 每次读写都同步的话，有一定的性能压力。

#### 6. Redis主从复制

##### 6.1 什么是主从复制

主从复制就是主机的数据更新后，根据配置或者策略自动同步到备机master/slaver的机制，**Master以写为主，Slave以读为主。**

##### 6.2 主从复制的目的

1. 读写分离
2. 容灾的快速恢复
3. ![image-20200917235306754](D:\git\picture\image-20200917235306754.png)



##### 6.3 主从配置













## 第七章 并发

#### 1.进程与线程

##### 	1.1 进程和线程

##### 	1.2 并行与并发

**并发（concurrent）**：是同一时间应对多件事请的能力。

**并行（parallel）**：是同一时间动手去做多件事情的能力。

##### 		1.3 同步和异步

#### 3. java线程

##### 	1.1 创建和运行线程

**Thread和Runnable的关系**

Thread是实现了Runnable接口的类，使用run支持多线程。

**FutureTask配合Thread创建线程**

FutureTask可以接收Callable类型的参数，用来处理有返回结果

```java
FutureTask<Integer> task = new FutureTask<Integer>(
    new Callable<Integer>() {
        @Override
        public Integer call() throws Exception {
            log.debug("Running....");
            Thread.sleep(2000);
            return 1000;
        }
    }
);
Thread t1 = new Thread(task, "t1");
```

##### 	1.2 线程运行原理

**线程的上下文切换**（Thread Context Switch）

​	因为一些原因导致cpu不再执行当前线程，转而执行其他线程的过程。

- 线程的cpu时间片用完
- 垃圾回收
- 有更高级的线程需要运行

**注意**频繁的发生上下文切换会影响到性能。

##### 1.3 线程的常见方法

**1.3.1 start和run方法**

**注意**线程的启动不能直接调用run方法，因为直接调用run方法只是相当于一次方法的调用，并不是启动线程。

***1.3.2 sleep***和***yield***

sleep

* sleep会使当前线程从Running状态进入到Timed_Waiting（阻塞）状态。
* 其他线程可以使用interrupt方法来打断正在睡眠的线程，这个时候sleep方法会抛出InterruptedException异常。
* 使用`TimeUnit.MINUTES.sleep(1);`来替代sleep可以提高程序的可读性。

yield

* 调用yield会使当前线程从Running进入到Runnable就绪状态，然后调度执行其他线程。

***1.3.3 join***

join方法表示无限等待，它会一直堵塞当前线程，直到目标线程执行完毕。比如一个线程非常依赖另一个线程的输入，则它就需要等待依赖线程执行完毕才能执行，这就需要join方法。yield方法表示会使当前线程让出cpu，这里的让出表示让出cpu后还会参与cpu资源的竞争。

使用join前

```java
public static void main(String[] args) throws InterruptedException {
    test1();
}

private static void test1() throws InterruptedException {
    log.debug("开始");
    Thread t1 = new Thread(() -> {
        log.debug("开始");
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("结束");
        r = 10;
    }, "t1");
    t1.start();
    //t1.join();
    log.debug("结果为:{}", r);
    log.debug("结束");
}
```

输出

```xml
14:53:24 [main] c.JoinMain - 开始
14:53:24 [main] c.JoinMain - 结果为:0
14:53:24 [main] c.JoinMain - 结束
14:53:24 [t1] c.JoinMain - 开始
14:53:24 [t1] c.JoinMain - 结束
```

使用join后输出

```xml
14:55:07 [main] c.JoinMain - 开始
14:55:07 [t1] c.JoinMain - 开始
14:55:07 [t1] c.JoinMain - 结束
14:55:07 [main] c.JoinMain - 结果为:10
14:55:07 [main] c.JoinMain - 结束
```

对于带参数的`join(long n);`的方法表示等待线程结束，**最多等待**n毫秒，如果n毫秒后没有执行完成，则继续向下执行。

**1.3.4 interrupt**

打断sleep、wait、join的线程时，会清空打断状态。

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -> {
        try {
            log.debug("t1 start...");
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "t1");
    thread.start();
    Thread.sleep(1000);
    log.debug("interupt");
    thread.interrupt();
    log.debug("打断标记{}", thread.isInterrupted());
}
```

输出结果

```xml
15:47:48 [t1] c.JoinMain - t1 start...
15:47:49 [main] c.JoinMain - interupt
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at test.Main.lambda$main$0(Main.java:16)
	at java.lang.Thread.run(Thread.java:745)
15:47:49 [main] c.JoinMain - 打断标记false
```

对于正常运行的线程，使用interrupt()并不会真正的打断线程，而是设定一个状态`isInetrrupted()`设定为`true`.



#### 2. 共享模型之管程

##### 2.1 synchronized解决共享问题

synchronized俗称【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其他线程再想获得这个【对象锁】时就会堵塞，保证临界区代码的安全执行，不用担心上下文切换。

##### 2.2 synchronized

synchronized实际上是用**对象锁**保证了**临界区代码的原子性**，临界区的代码对外是不可分割的，不会被线程切换所打断。

```java
synchronized (对象) {
    .......
}
```

```java
class Test{
    public synchronized void test() {
    }
}
等价于
class Test{
    public void test() {
        synchronized(this) {
        }
    }
}
```

```j
class Test{
    public synchronized static void test() {
    }
}
等价于
class Test{
    public static void test() {
        synchronized(Test.class) {
        }
    }
}
```



##### 2.3 变量的线程安全分析

* 成员变量和静态变量是否线程安全？

* 局部变量

  ​       局部变量是线程安全的，但是局部变量引用的对象未必是线程安全的。如果该对象没有逃离出方法的作用访问，则是线程安全的。如果逃离出方法的作用范围，则需要考虑线程安全。

* **不可变的线程安全类**

  String和Integer，因为其内部的状态不可以改变，因此他们都是线程安全的。



##### 2.4 Monitor

* java的对象头

  ```
  |--------------------------------------------------------------|
  |                       Object Header (64 bits)                |
  |------------------------------------|-------------------------|
  |                Mark Word (32 bits) | Klass Word (32 bits)    |
  |------------------------------------|-------------------------|
  ```

  其中 Mark Word 结构为

  ```
  |-------------------------------------------------------|--------------------|
  |                      Mark Word (32 bits)              | State              |
  |-------------------------------------------------------|--------------------|
  |        hashcode:25 | age:4 | biased_lock:0 | 01       |       Normal       |
  |-------------------------------------------------------|--------------------|
  |thread:23 | epoch:2 | age:4 | biased_lock:1 | 01       |       Biased       |
  |-------------------------------------------------------|--------------------|
  |                 ptr_to_lock_record:30      | 00       | Lightweight Locked |
  |-------------------------------------------------------|--------------------|
  |              ptr_to_heavyweight_monitor:30 | 10       | Heavyweight Locked |
  |-------------------------------------------------------|--------------------|
  |                                            | 11       |      Marked for GC |
  |-------------------------------------------------------|--------------------|
  ```

  

* Monitor原理

  Monitor被翻译成**监视器**或**管程**

  ​	每个Java对象都可以关联一个Monitor对象，如果用synchronized给对象加上锁（重量级）之后，，该对象的Mark Word中就被设置了指向Monitor的指针。

  Monitor 结构如下

  ![image-20200719230057239](D:\git\picture\image-20200719230057239.png)

  * 刚开始Monitor中的Owner为null
  * 当Thread-2执行synchronized(obj)就会把Monitor中的所有者Owner设置为Thread-2，Monitor中只能有一个Owner。
  * 在Thread-2上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入到EntryList BLOCKED。
  * Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的

  ​      **注意**：synchronized 必须是进入同一个对象的 monitor 才有上述的效果

* synchronized原理

##### 2.5 synchronized原理进阶

###### **轻量级锁**

应用场景：一个对象虽然有多线程要加锁，但加锁的时间是错开的，就可以用轻量级锁来优化。

轻量级锁对锁的使用者是透明的，即语法任然是`synchronized`.

假设有两个方法同步块，利用同一个对象进行加锁

```java
static final Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块 A
        method2();
    }
}
public static void method2() {
    synchronized( obj ) {
        // 同步块 B
    }
}
```

1.创建所的记录（Lock Record）对象，每个线程的栈帧都会包含一个**锁记录**的结构，内部可以**存储锁定对象的Mark World**。

![image-20200802171653824](D:\git\picture\image-20200802171653824.png)

2.让锁记录中的**Object reference指向加锁的对象**，并尝试用**cas**替换Object 的Mark Word，将Mark Word的值存入到锁记录。

![image-20200802174610915](D:\git\picture\image-20200802174610915.png)

3.如果**cas**成功，对象头中存储了**锁记录的地址和状态00**，表示该线程给对象加锁

![image-20200802175057716](D:\git\picture\image-20200802175057716.png)

4.如果cas失败，则有以下两种情况：

* 如果其他线程已经拥有了该对象的轻量级锁，这表明有竞争，则进入所膨胀的过程。
* 如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数。

![image-20200802175952246](D:\git\picture\image-20200802175952246.png)    5.当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。

![image-20200802180134764](D:\git\picture\image-20200802180134764.png)

6.当退出synchronized代码块（解锁）锁记录不为null，这时使用cas将Mark Word恢复给对象头。

* 成功，则解锁成功。
* 失败，说明轻量级锁已经进行所膨胀或者已经升级为重量级锁。

###### 锁膨胀

如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```java
static Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块
    }
}
```

1.当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁

![image-20200802203721688](D:\git\picture\image-20200802203721688.png)

2.这时 Thread-1 加轻量级锁失败，进入锁膨胀流程

* 即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址

* 然后自己进入 Monitor 的 EntryList BLOCKED

  ![image-20200802204345929](D:\git\picture\image-20200802204345929.png)

当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程



###### **自旋优化**



###### 偏向锁

轻量级锁轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。

Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。

```jade
static final Object obj = new Object();
public static void m1() {
    synchronized( obj ) {
        // 同步块 A
        m2();
    }
}
public static void m2() {
    synchronized( obj ) {
        // 同步块 B
        m3();
    }
}
public static void m3() {
    synchronized( obj ) {
        // 同步块 C
    }
}
```

![image-20200809104935555](D:\git\picture\image-20200809104935555.png)



![image-20200809105015338](D:\git\picture\image-20200809105015338.png)



###### 偏向状态

```hxml
|--------------------------------------------------------------------|--------------------|
|             Mark Word (64 bits)                                    |         State      |
|--------------------------------------------------------------------|--------------------|
| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0    | 01 |         Normal     |
|--------------------------------------------------------------------|--------------------|
| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1        | 01 |        Biased      |
|--------------------------------------------------------------------|--------------------|
|                        ptr_to_lock_record:62                  | 00 | Lightweight Locked |
|--------------------------------------------------------------------|--------------------|
|                 ptr_to_heavyweight_monitor:62                 | 10 | Heavyweight Locked |
|--------------------------------------------------------------------|--------------------|
|                                                               | 11 |    Marked for GC   |
|--------------------------------------------------------------------|--------------------|



```

一个对象创建时：

- 如果开启了偏向锁（默认了开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0。
- 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数`XX:BiasedLockingStartupDelay=0`来禁止延迟。
- 如果没有开启偏向锁，，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值。
- 撤销偏向锁的几种情况：调用对象的hashcode、其它线程使用对象、调用wait/notify



##### 2.6 wait notify

###### wait / notify原理

![image-20200809112330520](D:\git\picture\image-20200809112330520.png)

* Owner线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态
* BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片
* BLOCKED 线程会在 Owner 线程释放锁时唤醒
* WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入
  EntryList 重新竞争

###### API

* `obj.wait()`让进入 object 监视器的线程到 waitSet 等待
* `obj.notify()`在 object 上正在 waitSet 等待的线程中挑一个唤醒
* `obj.notifyAll()`让 object 上正在 waitSet 等待的线程全部唤醒

通常用法：

```java
synchronized(lock) {
    while(条件不成立) {
        lock.wait();
    }
    // 干活
}
//另一个线程
synchronized(lock) {
    lock.notifyAll();
}
```



##### 2.7 Park和UnPark

###### 基本使用

```java
// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark(暂停线程对象);
```

###### 特点

* wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必

* park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】

* park & unpark 可以先 unpark，而 wait & notify 不能先 notify

  

###### park & unpark原理

每个线程都有自己的**Parker**对象，由三部分组成`_counter`,`_cond`,`_mutex`。

![image-20200816194658825](D:\git\picture\image-20200816194658825.png)

1. 当线程调用`Unsafe.park()`方法
2. 检查_counter ，本情况为 0，这时，获得 _mutex 互斥锁
3. 线程进入 _cond 条件变量阻塞
4. 设置 _counter = 0

![image-20200816195102474](D:\git\picture\image-20200816195102474.png)

1. 调用 `Unsafe.unpark(Thread_0) `方法，设置 _counter 为 1

2. 唤醒 _cond 条件变量中的 Thread_0

3. Thread_0 恢复运行

4. 设置 _counter 为 0

   ![image-20200816195318182](D:\git\picture\image-20200816195318182.png)

   1. 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1
   2. 当前线程调用 Unsafe.park() 方法
   3. 检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行
   4. 设置 _counter 为 0



##### 2.8 线程状态转换

![image-20200816200053421](D:\git\picture\image-20200816200053421.png)

假设有线程`Thread t`

**情况一**：**`NEW --> RUNNABLE`**

* 当调用`t.start()`，由**NEW --> RUNNABLE**

**情况二**：**`RUNNABLE <--> WAITING`**

**t线程**用`synchronized(obj)`获取了对象锁后

* 调用了`obj.wait()`方法时，t线程从`RUNNABLE --> WAITING`
* 调用`obj.notify()`，`obj.notifyAll()`，`t.interrupt()`时
  * 竞争锁成功，**t 线程**从 **`WAITING --> RUNNABLE`**
  * 竞争锁失败，**t 线程**从 **`WAITING --> BLOCKED`**

**情况三**：**`RUNNABLE <--> WAITING`**

* **当前线程**调用 `t.join() `方法时，当前线程从 `RUNNABLE --> WAITING`
  * 注意是**当前线程**在**t 线程对象**的监视器上等待

* **t 线程**运行结束，或调用了**当前线程**的` interrupt() `时，**当前线程**从 `WAITING --> RUNNABLE`

**情况四：** **`RUNNABLE <--> WAITING`**

* **当前线程**调用 `LockSupport.park() `方法会让当前线程从 `RUNNABLE --> WAITING`
* 调用 `LockSupport.unpark(目标线程) `或调用了线程 的 `interrupt() `，会让目标线程从 **`WAITING -->
  RUNNABLE`**

**情况五：** `RUNNABLE <--> TIMED_WAITING`

**t线程**用`synchronized(obj)`获取了对象锁后

* 调用了`obj.wait(long n)`方法时，t线程从`RUNNABLE --> TIMED_WAITING`
* **t 线程**等待时间超过了 n 毫秒，调用`obj.notify()`，`obj.notifyAll()`，`t.interrupt()`时
  * 竞争锁成功，**t 线程**从 **`TIMED_WAITING --> RUNNABLE`**
  * 竞争锁失败，**t 线程**从 **`TIMED_WAITING --> BLOCKED`**

**情况六：** **`RUNNABLE <--> TIMED_WAITING`**

* **当前线程**调用 `t.join(long n) `方法时，**当前线程**从 `RUNNABLE --> TIMED_WAITING`
  * 注意是**当前线程**在**t 线程对象的监视器**上等待
* **当前线程**等待时间超过了 n 毫秒，或**t 线程**运行结束，或调用了**当前线程**的 `interrupt()` 时，当前线程从`TIMED_WAITING --> RUNNABLE`

**情况七：** **`RUNNABLE <--> TIMED_WAITING`**

* **当前线程**调用 `Thread.sleep(long n) `，**当前线程**从 `RUNNABLE --> TIMED_WAITING`
* **当前线程**等待时间超过了 n 毫秒，**当前线程**从 `TIMED_WAITING --> RUNNABLE`

**情况八：** `RUNNABLE <--> TIMED_WAITING`

* **当前线程**调用 `LockSupport.parkNanos(long nanos) `或 `LockSupport.parkUntil(long millis)` 时，当前线程从 `RUNNABLE --> TIMED_WAITING`
* 调用 `LockSupport.unpark(目标线程) `或调用了线程 的` interrupt() `，或是等待超时，会让**目标线程**从`TIMED_WAITING--> RUNNABLE`

**情况九：** `RUNNABLE <--> BLOCKED`

* **t 线程**用 `synchronized(obj) `获取了对象锁时如果竞争失败，从 `RUNNABLE --> BLOCKED`
* 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 `BLOCKED `的线程重新竞争，如果其中 t 线程**竞争成功**，从 `BLOCKED --> RUNNABLE` ，其它失败的线程仍然 `BLOCKED`

**情况十：** `RUNNABLE <--> TERMINATED`

当前线程所有代码运行完毕，进入`TERMINATED`



##### 2.9 活跃性

###### 死锁

一个线程同时获取多把锁就容易产生死锁。

```java
Object o1 = new Object();
Object o2 = new Object();
Thread thread1 = new Thread(() -> {
    synchronized (o1) {
        log.debug("lock 1");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (o2) {
            log.debug("lock 2");
        }
    }
}, "t1");

Thread thread2 = new Thread(() -> {
    synchronized (o2) {
        log.debug("lock 2");
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (o1) {
            log.debug("lock 1");
        }
    }
}, "t2");

thread1.start();
thread2.start();
```



###### 活锁

两个线程相互改变对方结束的条件，给过谁也无法结束

```java
static final Object lock = new Object();
public static void main(String[] args) {
    new Thread(() -> {
        // 期望减到 0 退出循环
        while (count > 0) {
            sleep(0.2);
            count--;
            log.debug("count: {}", count);
        }
    }, "t1").start();
    new Thread(() -> {
        // 期望超过 20 退出循环
        while (count < 20) {
            sleep(0.2);
            count++;
            log.debug("count: {}", count);
        }
     }, "t2").start();
}
```



###### 饥饿

很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束。



##### 2.10 ReentrantLock

相比于synchronized有如下特点：

* 可中断
* 可以设置超时时间
* 可以设置为公平锁
* 支持多个条件变量

和synchronized都支持可重入

基本语法

```java
// 获取锁
reentrantLock.lock();
    try {
        // 临界区
    } finally {
        // 释放锁
        reentrantLock.unlock();
    }
```



###### 可重入

可重入是指当前线程首次获得了该把锁，那么它有权利可以再次获得该锁。

###### 可打断

```java
Thread thread = new Thread(() -> {
    log.debug("启动。。。");
    try {
        lock.lockInterruptibly();
    } catch (InterruptedException e) {
        e.printStackTrace();
        log.debug("锁等待的过程中被打断");
        return;
    }
    try {
        log.debug("获得了锁");
    } finally {
        lock.unlock();
    }

}, "t1");
lock.lock();
log.debug("获得了锁");
thread.start();
try {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    thread.interrupt();
    log.debug("执行打断");
} finally {
    lock.unlock();
}
```



###### 锁超时

* `lock.tryLock()`获取锁失败后，返回false。
* `lock.tryLock(long timeout, TimeUnit unit)`在既定的时间内获取锁，到达既定时间没有获取到锁，返回false，否则返回true。



###### 公平锁

`ReentrantLock(boolean fair)`



###### 条件变量

synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待，ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的。这就好比：**synchronized 是那些不满足条件的线程都在一间休息室等消息**，而 **ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒**。

使用要点：

* await 前需要获得锁
* await 执行后，会释放锁，进入 conditionObject 等待
* await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁
* 竞争 lock 锁成功后，从 await 后继续执行

```java
public static ReentrantLock lock = new ReentrantLock();
public static Condition waitCigaretteQueue = lock.newCondition();
public static Condition waitbreakfastQueue = lock.newCondition();
static volatile boolean hasCigrette = false;
static volatile boolean hasBreakfast = false;

public static void main(String[] args) {
    new Thread(() -> {
        try {
            lock.lock();
            log.debug("有烟没有？");
            while (!hasCigrette) {
                log.debug("没有烟，等待香烟");
                try {
                    waitCigaretteQueue.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("香烟来了,可以工作了");
        } finally {
            lock.unlock();
        }
    }, "小南").start();
    new Thread(() -> {
        try {
            lock.lock();
            log.debug("有早餐没有？");
            while (!hasCigrette) {
                log.debug("没有早餐，等待早餐");
                try {
                    waitbreakfastQueue.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("早餐来了,可以工作了");
        } finally {
            lock.unlock();
        }
    }, "小北").start();

    try {
        Thread.sleep(1000);
        sendCigarette();
        Thread.sleep(1000);
        sendBreakfast();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

}

private static void sendCigarette() {
    lock.lock();
    try {
        log.debug("送烟来了");
        hasCigrette = true;
        waitCigaretteQueue.signal();
    } finally {
        lock.unlock();
    }
}

private static void sendBreakfast() {
    lock.lock();
    try {
        log.debug("送早餐来了");
        hasBreakfast = true;
        waitbreakfastQueue.signal();
    } finally {
        lock.unlock();
    }
}
```



#### 4.共享模型之内存

##### 4.1 内存模型

JMM即java memory model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。

JMM主要体现在：

* 原子性 -指令不受上下文切换的影响。
* 可见性 -指令不受cpu缓存的影响。
* 有序性 -指令不受cpu指令行优化的影响。

##### 4.2 可见性

先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：

```java
static boolean run = true;
    public static void main(String[] args) {
        Thread t = new Thread(()->{
            while(run){
               // ....
            }
        });
        t.start();
        run = false; // 线程t不会如预想的停下来
}
```

具体原因

1. 初始状态，t线程刚从主线程读取了run的值到工作内存。

   ![image-20200909223500236](D:\git\picture\image-20200909223500236.png)

2. 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率。

   ![image-20200909223659506](D:\git\picture\image-20200909223659506.png)

3. main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。

   ![image-20200909224116684](D:\git\picture\image-20200909224116684.png)

解决上述问题的方法是用**volatile**关键字去修饰变量。它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。

**可见性VS原子性**

​    前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：

```
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
getstatic run // 线程 t 获取 run true 
putstatic run // 线程 main 修改 run 为 false， 仅此一次
getstatic run // 线程 t 获取 run false
```

两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错:

```
// 假设i的初始值为0 
getstatic     i // 线程2-获取静态变量i的值 线程内i=0 

getstatic     i // 线程1-获取静态变量i的值 线程内i=0 
iconst_1        // 线程1-准备常量1 
iadd            // 线程1-自增 线程内i=1 
putstatic     i // 线程1-将修改后的值存入静态变量i 静态变量i=1 

iconst_1        // 线程2-准备常量1 
isub            // 线程2-自减 线程内i=-1 
putstatic     i // 线程2-将修改后的值存入静态变量i 静态变量i=-1
```

**注意**：**synchronized** 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是**synchronized** 是属于重量级操作，性能相对更低。

##### 4.3 有序性

JVM会在不影响正确性的前提下，可以调整指令的执行顺序。这种特性称之为**『指令重排』**，多线程下**『指令重排』**会影响正确性。

**volatile 修饰的变量，可以禁用指令重排**

##### 4.4 volatile的原理

volatile的底层实现原理是内存屏障，Memory Barrier（Memory Fence）。

* 对 volatile 变量的**写指令后**会加入写屏障
* 对 volatile 变量的**读指令前**会加入读屏障

如何保证可见性：

  写屏障（sfence）保证在写屏障之前的，对共享变量的改动都会同步到主存当中。

```
public void actor2(I_Result r) {
    num = 2;
    ready = true; // ready 是 volatile 赋值带写屏障
    // 写屏障
}

```

而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据.

```
public void actor1(I_Result r) {
    // 读屏障
    // ready 是 volatile 读取值带读屏障
    if(ready) {
        r.r1 = num + num;
    } else { 
        r.r1 = 1;
    }
}
```

![image-20200916230100849](D:\git\picture\image-20200916230100849.png)



还是那句话，不能解决指令交错：

* 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去
* 而有序性的保证也只是保证了本线程内相关代码不被重排序

![image-20200917214741038](D:\git\picture\image-20200917214741038.png)





##### 4.6 double-checked locking 问题

```
public final class Singleton {

    /**
     * 构造函数
     */
    private Singleton() {
    }

    /**
     * 实例变量
     */
    private static Singleton INSTANCE = null;

    /**
     * 生成实例对象
     *
     * @return 对象
     */
    public static Singleton getInstance() {
        if (INSTANCE == null) {
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

上述实现的特点是：

* 懒惰实例化
* 首次使用`getInstance()`方法才使用synchronized 加锁，后续使用时无需加锁。
* **有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下，上面的代码是有问题的。**

getInstance 方法对应的字节码为：

```
0: getstatic      #2   // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull      37
6: ldc            #3   // class cn/itcast/n5/Singleton
8: dup
9: astore_0
10: monitorenter
11: getstatic     #2   // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull     27
17: new           #3   // class cn/itcast/n5/Singleton
20: dup
21: invokespecial #4   // Method "<init>":()V
24: putstatic     #2   // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic    #2   // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn
```

其中

* 17 表示创建对象，将对象引用入栈 // new Singleton
* 20 表示复制一份对象引用 // 引用地址
* 21 表示利用一个对象引用，调用构造方法。
* 24 表示利用一个对象引用，赋值给 static INSTANCE

**也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：**

![image-20200917220739121](D:\git\picture\image-20200917220739121.png)

关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取
INSTANCE 变量的值。

这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初
始化完毕的单例

对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效

##### 4.7 double-checked locking 解决

```
public final class Singleton {
    private Singleton() { }
    private static volatile Singleton INSTANCE = null;
    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) { 
            synchronized (Singleton.class) { // t2
               // 也许有其它线程已经创建实例，所以再判断一次
               if (INSTANCE == null) { // t1
                   INSTANCE = new Singleton();
               }
            }
       }
       return INSTANCE;
    }
}

```

字节码

```
// -------------------------------------> 加入对 INSTANCE 变量的读屏障
0: getstatic      #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull      37
6: ldc            #3 // class cn/itcast/n5/Singleton
8: dup
9: astore_0
10: monitorenter -----------------------> 保证原子性、可见性
11: getstatic     #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull     27
17: new           #3 // class cn/itcast/n5/Singleton
20: dup
21: invokespecial #4 // Method "<init>":()V
24: putstatic     #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
// -------------------------------------> 加入对 INSTANCE 变量的写屏障
27: aload_0
28: monitorexit ------------------------> 保证原子性、可见性
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn

```

如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：

* 可见性
  * 写屏障：（sfence）保证在该屏障之前的对t1对共享变量的改动都会同步到主存当中。
  * 而读屏障（lfence）保证再读屏障之后t2对共享变量的读取都是最新的数据。
* 有序性
  * 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
  * 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

















## 第八章 微服务框架

#### 1. Nginx

##### 1.1 Nginx简介

Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。

##### 1.2 正向代理和反向代理

##### 1.3 Nginx的安装

* 首先需要四个的压缩包`pcre-8.37.tar.gz`,`zlib-1.2.8.tar.gz`,`openssl-1.0.1t.tar.gz`,`nginx-1.11.1.tar.gz`,将压缩包放到linux的opt目录下。

* 首先安装pcre

  解压

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 opt]# tar -zxvf pcre-8.37.tar.gz
  ```

  执行配置文件

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 pcre-8.37]# ./configure
  ```

  编译

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 pcre-8.37]# make
  ```

  安装

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 pcre-8.37]# make install
  ```

  

* 安装openss

  解压

  ```
  [root@ecs-x-medium-2-linux-20200312095042 opt]# tar -zxvf openssl-1.0.1t.tar.gz
  ```

  执行配置文件

  ```
  [root@ecs-x-medium-2-linux-20200312095042 openssl-1.0.1t]# ./config
  ```

  编译

  ```
  [root@ecs-x-medium-2-linux-20200312095042 openssl-1.0.1t]# make
  ```

  安装

  ```
  [root@ecs-x-medium-2-linux-20200312095042 openssl-1.0.1t]# make install
  ```



* 安装zlib

  解压、执行配置文件

  ```
  [root@ecs-x-medium-2-linux-20200312095042 zlib-1.2.8]# ./configue
  ```

  编译和安装

  ```
  [root@ecs-x-medium-2-linux-20200312095042 zlib-1.2.8]# make && make install
  ```

  

* 安装nginx

  解压和执行配置文件

  ```
  [root@ecs-x-medium-2-linux-20200312095042 nginx-1.11.1]# ./configure
  ```

  编译和安装

  ```
  [root@ecs-x-medium-2-linux-20200312095042 nginx-1.11.1]# make && make install
  ```

  

* 执行

  ```
  [root@ecs-x-medium-2-linux-20200312095042 sbin]# ./nginx
  ```

  成功页面

  ![成功](C:\Users\15771\Desktop\image-20200706002805760.png)

* 相关命令

  在`/usr/local/nginx/sbin`目录下，关闭命令` ./nginx -s stop`，重新加载命令`./nginx -s reload`

