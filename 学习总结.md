# java学习的大体路线

![学习路线](C:\Users\15771\Desktop\picture\微信图片_20200630213416.jpg)

计划

> 自己关于如何学好的初步尝试：
>
> ​	1.在项目中学习相关技术，因为自己学的话根本不知道从何学起，只有通过**项目视频**来总结相关技术。
>
> ​    2.利用好平时的时间，*明确自己要学习什么*？
>
> ​    3.**一定要提高效率！！！**
>
> ​    4.**定好目标**，明确自己在一段时间内的的目标，**以一段时间为单位制定计划**。包括制定好每天要学习什么，每天要完成什么。
>
> |    Monday    | Tuesday | Wednesday |       Thursday       | Friday | Saturday |
> | :----------: | :-----: | :-------: | :------------------: | :----: | :------: |
> |              |         |           |                      |        |          |
> |   学习算法   |         |           |      看JVM视频       |        |          |
> |              |         |           |                      |        |          |
> | 看spring相关 |         |           | 看并发编程相关的视频 |        |          |
> |              |         |           |                      |        |          |
> |              |         |           |                      |        |          |
> |              |         |           |                      |        |          |
> |              |         |           |                      |        |          |
>
> 

## 第一章 java基础

## 第二章 spring相关

## <center>Spring注解驱动开发</center>

#### 1. 组件注册

##### 1.1 常用注解

1.1.1 **@Configuration**和**@Bean**

1.1.2 **@ComponentScan**

1.1.3 **@Scope**

1.1.4 **@Lazy**

1.1.5 **@Conditional**

1.1.6 **@Import**

## 第三章 mybatis和mysql相关

## 第四章 JVM相关

#### 

## 第五章 消息中间件

## 第六章 分布式缓存

## 第七章 并发编程

#### 1.进程与线程

##### 	1.1 进程和线程

##### 	1.2 并行与并发

**并发（concurrent）**：是同一时间应对多件事请的能力。

**并行（parallel）**：是同一时间动手去做多件事情的能力。

##### 		1.3 同步和异步

#### 3. java线程

##### 	1.1 创建和运行线程

**Thread和Runnable的关系**

Thread是实现了Runnable接口的类，使用run支持多线程。

**FutureTask配合Thread创建线程**

FutureTask可以接收Callable类型的参数，用来处理有返回结果

```java
FutureTask<Integer> task = new FutureTask<Integer>(
    new Callable<Integer>() {
        @Override
        public Integer call() throws Exception {
            log.debug("Running....");
            Thread.sleep(2000);
            return 1000;
        }
    }
);
Thread t1 = new Thread(task, "t1");
```

##### 	1.2 线程运行原理

**线程的上下文切换**（Thread Context Switch）

​	因为一些原因导致cpu不再执行当前线程，转而执行其他线程的过程。

- 线程的cpu时间片用完
- 垃圾回收
- 有更高级的线程需要运行

**注意**频繁的发生上下文切换会影响到性能。

##### 1.3 线程的常见方法

**1.3.1 start和run方法**

**注意**线程的启动不能直接调用run方法，因为直接调用run方法只是相当于一次方法的调用，并不是启动线程。

***1.3.2 sleep***和***yield***

sleep

* sleep会使当前线程从Running状态进入到Timed_Waiting（阻塞）状态。
* 其他线程可以使用interrupt方法来打断正在睡眠的线程，这个时候sleep方法会抛出InterruptedException异常。
* 使用`TimeUnit.MINUTES.sleep(1);`来替代sleep可以提高程序的可读性。

yield

* 调用yield会使当前线程从Running进入到Runnable就绪状态，然后调度执行其他线程。

***1.3.3 join***

join方法表示无限等待，它会一直堵塞当前线程，直到目标线程执行完毕。比如一个线程非常依赖另一个线程的输入，则它就需要等待依赖线程执行完毕才能执行，这就需要join方法。yield方法表示会使当前线程让出cpu，这里的让出表示让出cpu后还会参与cpu资源的竞争。

使用join前

```java
public static void main(String[] args) throws InterruptedException {
    test1();
}

private static void test1() throws InterruptedException {
    log.debug("开始");
    Thread t1 = new Thread(() -> {
        log.debug("开始");
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("结束");
        r = 10;
    }, "t1");
    t1.start();
    //t1.join();
    log.debug("结果为:{}", r);
    log.debug("结束");
}
```

输出

```xml
14:53:24 [main] c.JoinMain - 开始
14:53:24 [main] c.JoinMain - 结果为:0
14:53:24 [main] c.JoinMain - 结束
14:53:24 [t1] c.JoinMain - 开始
14:53:24 [t1] c.JoinMain - 结束
```

使用join后输出

```xml
14:55:07 [main] c.JoinMain - 开始
14:55:07 [t1] c.JoinMain - 开始
14:55:07 [t1] c.JoinMain - 结束
14:55:07 [main] c.JoinMain - 结果为:10
14:55:07 [main] c.JoinMain - 结束
```

对于带参数的`join(long n);`的方法表示等待线程结束，**最多等待**n毫秒，如果n毫秒后没有执行完成，则继续向下执行。

**1.3.4 interrupt**

打断sleep、wait、join的线程时，会清空打断状态。

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -> {
        try {
            log.debug("t1 start...");
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "t1");
    thread.start();
    Thread.sleep(1000);
    log.debug("interupt");
    thread.interrupt();
    log.debug("打断标记{}", thread.isInterrupted());
}
```

输出结果

```xml
15:47:48 [t1] c.JoinMain - t1 start...
15:47:49 [main] c.JoinMain - interupt
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at test.Main.lambda$main$0(Main.java:16)
	at java.lang.Thread.run(Thread.java:745)
15:47:49 [main] c.JoinMain - 打断标记false
```

对于正常运行的线程，使用interrupt()并不会真正的打断线程，而是设定一个状态`isInetrrupted()`设定为`true`.

<front color='red'>1.3.5 两段终止模式</front>





## 第八章 微服务框架

#### 1. Nginx

##### 1.1 Nginx简介

Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。

##### 1.2 正向代理和反向代理

##### 1.3 Nginx的安装

* 首先需要四个的压缩包`pcre-8.37.tar.gz`,`zlib-1.2.8.tar.gz`,`openssl-1.0.1t.tar.gz`,`nginx-1.11.1.tar.gz`,将压缩包放到linux的opt目录下。

* 首先安装pcre

  解压

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 opt]# tar -zxvf pcre-8.37.tar.gz
  ```

  执行配置文件

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 pcre-8.37]# ./configure
  ```

  编译

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 pcre-8.37]# make
  ```

  安装

  ```xml
  [root@ecs-x-medium-2-linux-20200312095042 pcre-8.37]# make install
  ```

  

* 安装openss

  解压

  ```
  [root@ecs-x-medium-2-linux-20200312095042 opt]# tar -zxvf openssl-1.0.1t.tar.gz
  ```

  执行配置文件

  ```
  [root@ecs-x-medium-2-linux-20200312095042 openssl-1.0.1t]# ./config
  ```

  编译

  ```
  [root@ecs-x-medium-2-linux-20200312095042 openssl-1.0.1t]# make
  ```

  安装

  ```
  [root@ecs-x-medium-2-linux-20200312095042 openssl-1.0.1t]# make install
  ```



* 安装zlib

  解压、执行配置文件

  ```
  [root@ecs-x-medium-2-linux-20200312095042 zlib-1.2.8]# ./configue
  ```

  编译和安装

  ```
  [root@ecs-x-medium-2-linux-20200312095042 zlib-1.2.8]# make && make install
  ```

  

* 安装nginx

  解压和执行配置文件

  ```
  [root@ecs-x-medium-2-linux-20200312095042 nginx-1.11.1]# ./configure
  ```

  编译和安装

  ```
  [root@ecs-x-medium-2-linux-20200312095042 nginx-1.11.1]# make && make install
  ```

  

* 执行

  ```
  [root@ecs-x-medium-2-linux-20200312095042 sbin]# ./nginx
  ```

  成功页面

  ![成功](C:\Users\15771\Desktop\image-20200706002805760.png)

* 相关命令

  在`/usr/local/nginx/sbin`目录下，关闭命令` ./nginx -s stop`，重新加载命令`./nginx -s reload`